name: Main

on:
  push:
    # Run the entire pipeline for 'main' even though the merge queue already runs checks
    # for every change. This just offers an extra layer of testing and covers the case of
    # random force pushes.
    branches: ["main"]
  pull_request:
    types: ['opened', 'synchronize']
    branches: ["**"]
  merge_group:
    types: [checks_requested]
  workflow_dispatch:

jobs:
  build-result:
    name: Result
    runs-on: ubuntu-latest
    if: always()
    steps:
        if: ${{ !contains(needs.*.result, 'failure') && !contains(needs.*.result, 'cancelled') }}
        run: exit 0
      - name: Failure
        if: contains(needs.*.result, 'failure') || contains(needs.*.result, 'cancelled')
        run: exit 1
